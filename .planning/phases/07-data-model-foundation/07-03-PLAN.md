---
phase: 07-data-model-foundation
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - lib/db/queries/topics.ts
  - lib/db/queries/detail-links.ts
  - lib/db/queries/index.ts
  - lib/utils/legislative-format.ts
autonomous: true

must_haves:
  truths:
    - "Query function returns details from multiple sources for a given topic"
    - "Query function returns detail with linked supplementary content"
    - "Legislative references format correctly as NZBC citations"
  artifacts:
    - path: "lib/db/queries/topics.ts"
      provides: "getDetailsByTopic function for unified navigation"
      exports: ["getDetailsByTopic", "getTopicsWithCounts"]
    - path: "lib/db/queries/detail-links.ts"
      provides: "getDetailWithLinks function for related content"
      exports: ["getDetailWithLinks", "createDetailLink"]
    - path: "lib/utils/legislative-format.ts"
      provides: "NZBC citation formatting utility"
      exports: ["formatNZBCCitation", "inferAuthorityLevel"]
  key_links:
    - from: "lib/db/queries/topics.ts"
      to: "topics, categoryTopics, details tables"
      via: "Drizzle ORM joins"
      pattern: "from.*topics.*join.*categoryTopics"
    - from: "lib/db/queries/detail-links.ts"
      to: "detailLinks, details tables"
      via: "Drizzle ORM joins"
      pattern: "from.*detailLinks.*join.*details"
---

<objective>
Create query functions for topic-based detail retrieval and cross-source linked content.

Purpose: Implement the query layer for DATA-01 (getDetailWithLinks) and DATA-02 (getDetailsByTopic). These functions enable Phase 9 (Unified Navigation) and Phase 10 (Detail Page Enhancement) to show content from multiple sources in a unified view.

Output: Type-safe query functions for topic queries, detail linking, and NZBC citation formatting.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-data-model-foundation/07-RESEARCH.md
@.planning/phases/07-data-model-foundation/07-01-SUMMARY.md
@lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create topic query functions</name>
  <files>lib/db/queries/topics.ts</files>
  <action>
Create `lib/db/queries/topics.ts` with functions for topic-based queries:

```typescript
import { db } from '@/lib/db';
import { topics, categoryTopics, categories, details, contentSources } from '@/lib/db/schema';
import { eq, inArray, and, asc, desc, sql } from 'drizzle-orm';

export interface TopicWithCounts {
  id: string;
  name: string;
  description: string | null;
  iconUrl: string | null;
  sortOrder: number;
  categoryCount: number;
  detailCount: number;
}

export interface GetDetailsByTopicOptions {
  sourceId?: string;
  limit?: number;
  offset?: number;
  orderBy?: 'code' | 'name' | 'updatedAt';
}

/**
 * Get all topics with category and detail counts
 */
export async function getTopicsWithCounts(): Promise<TopicWithCounts[]> {
  // Use raw SQL for complex aggregation
  const result = await db.execute(sql`
    SELECT
      t.id,
      t.name,
      t.description,
      t.icon_url as "iconUrl",
      t.sort_order as "sortOrder",
      COUNT(DISTINCT ct.category_id) as "categoryCount",
      COUNT(DISTINCT d.id) as "detailCount"
    FROM topics t
    LEFT JOIN category_topics ct ON t.id = ct.topic_id
    LEFT JOIN categories c ON ct.category_id = c.id
    LEFT JOIN details d ON d.category_id = c.id
    GROUP BY t.id, t.name, t.description, t.icon_url, t.sort_order
    ORDER BY t.sort_order
  `);

  return result.rows as TopicWithCounts[];
}

/**
 * Get details by topic with optional source filter
 * Enables unified navigation: "show all flashings from all sources"
 */
export async function getDetailsByTopic(
  topicId: string,
  options: GetDetailsByTopicOptions = {}
) {
  const { sourceId, limit = 20, offset = 0, orderBy = 'code' } = options;

  // Get categories mapped to this topic
  const topicCategories = await db
    .select({ categoryId: categoryTopics.categoryId })
    .from(categoryTopics)
    .where(eq(categoryTopics.topicId, topicId));

  if (topicCategories.length === 0) {
    return { data: [], total: 0 };
  }

  const categoryIds = topicCategories.map(c => c.categoryId);

  // Build conditions
  const conditions = [inArray(details.categoryId, categoryIds)];
  if (sourceId) {
    conditions.push(eq(details.sourceId, sourceId));
  }

  // Get total count
  const [countResult] = await db
    .select({ count: sql<number>`count(*)` })
    .from(details)
    .where(and(...conditions));

  // Get details with source info
  const orderColumn = orderBy === 'code' ? details.code
    : orderBy === 'name' ? details.name
    : details.updatedAt;

  const data = await db
    .select({
      id: details.id,
      code: details.code,
      name: details.name,
      description: details.description,
      thumbnailUrl: details.thumbnailUrl,
      modelUrl: details.modelUrl,
      categoryId: details.categoryId,
      sourceId: details.sourceId,
      sourceName: contentSources.shortName,
    })
    .from(details)
    .leftJoin(contentSources, eq(details.sourceId, contentSources.id))
    .where(and(...conditions))
    .orderBy(orderBy === 'updatedAt' ? desc(orderColumn) : asc(orderColumn))
    .limit(limit)
    .offset(offset);

  return {
    data,
    total: Number(countResult.count),
    limit,
    offset,
  };
}

/**
 * Get a single topic by ID
 */
export async function getTopicById(topicId: string) {
  const [topic] = await db
    .select()
    .from(topics)
    .where(eq(topics.id, topicId))
    .limit(1);

  return topic ?? null;
}
```

Use existing Drizzle patterns from the codebase. Import necessary operators from drizzle-orm.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit lib/db/queries/topics.ts`
Exports are available: getDetailsByTopic, getTopicsWithCounts, getTopicById
  </verify>
  <done>
Topic query functions created with proper typing and source filtering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create detail links query functions</name>
  <files>lib/db/queries/detail-links.ts</files>
  <action>
Create `lib/db/queries/detail-links.ts` with functions for cross-source linking:

```typescript
import { db } from '@/lib/db';
import { detailLinks, details, contentSources } from '@/lib/db/schema';
import { eq, and, or } from 'drizzle-orm';
import { nanoid } from 'nanoid';

export type LinkType = 'installation_guide' | 'technical_supplement' | 'alternative';
export type MatchConfidence = 'exact' | 'partial' | 'related';

export interface DetailLink {
  id: string;
  primaryDetailId: string;
  supplementaryDetailId: string;
  linkType: LinkType;
  matchConfidence: MatchConfidence | null;
  notes: string | null;
  createdAt: Date;
}

export interface LinkedDetail {
  id: string;
  code: string;
  name: string;
  description: string | null;
  thumbnailUrl: string | null;
  modelUrl: string | null;
  sourceId: string | null;
  sourceName: string | null;
  linkType: LinkType;
  matchConfidence: MatchConfidence | null;
}

export interface DetailWithLinks {
  // ... detail fields
  supplements: LinkedDetail[];    // Content this detail links TO (as primary)
  supplementsTo: LinkedDetail[];  // Content that links TO this detail (as supplementary)
}

/**
 * Get detail with all linked content (both directions)
 * Returns MRM detail with linked RANZ guides, or RANZ guide with linked MRM specs
 */
export async function getDetailWithLinks(detailId: string): Promise<DetailWithLinks | null> {
  // Get base detail
  const [detail] = await db
    .select({
      id: details.id,
      code: details.code,
      name: details.name,
      description: details.description,
      thumbnailUrl: details.thumbnailUrl,
      modelUrl: details.modelUrl,
      sourceId: details.sourceId,
      categoryId: details.categoryId,
      substrateId: details.substrateId,
      minPitch: details.minPitch,
      maxPitch: details.maxPitch,
      specifications: details.specifications,
      standardsRefs: details.standardsRefs,
      ventilationReqs: details.ventilationReqs,
    })
    .from(details)
    .where(eq(details.id, detailId))
    .limit(1);

  if (!detail) return null;

  // Get supplementary content (where this detail is primary)
  const supplements = await db
    .select({
      id: details.id,
      code: details.code,
      name: details.name,
      description: details.description,
      thumbnailUrl: details.thumbnailUrl,
      modelUrl: details.modelUrl,
      sourceId: details.sourceId,
      sourceName: contentSources.shortName,
      linkType: detailLinks.linkType,
      matchConfidence: detailLinks.matchConfidence,
    })
    .from(detailLinks)
    .innerJoin(details, eq(detailLinks.supplementaryDetailId, details.id))
    .leftJoin(contentSources, eq(details.sourceId, contentSources.id))
    .where(eq(detailLinks.primaryDetailId, detailId));

  // Get primary content (where this detail is supplementary)
  const supplementsTo = await db
    .select({
      id: details.id,
      code: details.code,
      name: details.name,
      description: details.description,
      thumbnailUrl: details.thumbnailUrl,
      modelUrl: details.modelUrl,
      sourceId: details.sourceId,
      sourceName: contentSources.shortName,
      linkType: detailLinks.linkType,
      matchConfidence: detailLinks.matchConfidence,
    })
    .from(detailLinks)
    .innerJoin(details, eq(detailLinks.primaryDetailId, details.id))
    .leftJoin(contentSources, eq(details.sourceId, contentSources.id))
    .where(eq(detailLinks.supplementaryDetailId, detailId));

  return {
    ...detail,
    supplements: supplements as LinkedDetail[],
    supplementsTo: supplementsTo as LinkedDetail[],
  };
}

/**
 * Create a link between two details
 * Primary = authoritative (typically MRM), Supplementary = enriching (typically RANZ)
 */
export async function createDetailLink(
  primaryDetailId: string,
  supplementaryDetailId: string,
  linkType: LinkType,
  matchConfidence?: MatchConfidence,
  notes?: string
): Promise<DetailLink> {
  const id = nanoid();

  const [link] = await db
    .insert(detailLinks)
    .values({
      id,
      primaryDetailId,
      supplementaryDetailId,
      linkType,
      matchConfidence: matchConfidence ?? null,
      notes: notes ?? null,
    })
    .returning();

  return link as DetailLink;
}

/**
 * Get all links for a detail (both directions)
 */
export async function getLinksForDetail(detailId: string) {
  return db
    .select()
    .from(detailLinks)
    .where(
      or(
        eq(detailLinks.primaryDetailId, detailId),
        eq(detailLinks.supplementaryDetailId, detailId)
      )
    );
}

/**
 * Delete a link between details
 */
export async function deleteDetailLink(linkId: string) {
  return db
    .delete(detailLinks)
    .where(eq(detailLinks.id, linkId));
}
```

Types should align with schema definitions and support Phase 10 (Detail Page Enhancement) needs.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit lib/db/queries/detail-links.ts`
Exports: getDetailWithLinks, createDetailLink, getLinksForDetail, deleteDetailLink
  </verify>
  <done>
Detail link query functions created with bidirectional link support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create NZBC citation formatting utility and query index</name>
  <files>lib/utils/legislative-format.ts, lib/db/queries/index.ts</files>
  <action>
1. Create `lib/utils/legislative-format.ts`:

```typescript
/**
 * NZBC citation formatting utilities
 * Formats legislative references according to NZ Building Code standards
 */

export interface LegislativeRef {
  code: string;       // 'E2/AS1'
  edition?: string;   // '4th'
  amendment?: string; // 'Amd 10'
  clause: string;     // 'Table 20'
  title?: string;
}

/**
 * Format a legislative reference as a proper NZBC citation
 * Examples:
 *   { code: 'E2/AS1', edition: '4th', clause: 'Table 20' }
 *   => "E2/AS1 (4th edition) Table 20"
 *
 *   { code: 'E2/AS1', amendment: 'Amd 10', clause: '8.4.8' }
 *   => "E2/AS1 (Amd 10) 8.4.8"
 */
export function formatNZBCCitation(ref: LegislativeRef): string {
  const parts: string[] = [ref.code];

  if (ref.edition) {
    parts.push(`(${ref.edition} edition)`);
  } else if (ref.amendment) {
    parts.push(`(${ref.amendment})`);
  }

  if (ref.clause) {
    parts.push(ref.clause);
  }

  return parts.join(' ');
}

/**
 * Format with title for full display
 * => "E2/AS1 (4th edition) Table 20 - Flashing dimensions"
 */
export function formatNZBCCitationWithTitle(ref: LegislativeRef): string {
  const citation = formatNZBCCitation(ref);
  if (ref.title) {
    return `${citation} - ${ref.title}`;
  }
  return citation;
}

/**
 * Infer authority level from code format
 * - Building Code: E2, B2 (clause only)
 * - Acceptable Solution: E2/AS1
 * - Verification Method: E2/VM1
 * - Determination: everything else
 */
export function inferAuthorityLevel(code: string): 'building_code' | 'acceptable_solution' | 'verification_method' | 'determination' {
  if (code.match(/^[A-Z]\d+$/)) return 'building_code';       // E2, B2
  if (code.includes('/AS')) return 'acceptable_solution';     // E2/AS1
  if (code.includes('/VM')) return 'verification_method';     // E2/VM1
  return 'determination';
}

/**
 * Parse a citation string into components
 * Handles: "E2/AS1 Table 20", "E2/AS1 (4th edition) Table 20"
 */
export function parseCitation(citation: string): Partial<LegislativeRef> {
  const parts: Partial<LegislativeRef> = {};

  // Match code (E2/AS1, B2, etc.)
  const codeMatch = citation.match(/^([A-Z]\d+(?:\/[AV][SM]\d+)?)/);
  if (codeMatch) {
    parts.code = codeMatch[1];
  }

  // Match edition in parentheses
  const editionMatch = citation.match(/\((\d+(?:st|nd|rd|th)) edition\)/i);
  if (editionMatch) {
    parts.edition = editionMatch[1];
  }

  // Match amendment in parentheses
  const amdMatch = citation.match(/\(Amd(?:endment)?\s*(\d+)\)/i);
  if (amdMatch) {
    parts.amendment = `Amd ${amdMatch[1]}`;
  }

  // Remaining text is clause/table reference
  const clauseMatch = citation.match(/(Table|Clause|Section|Figure)\s+[\d.]+/i);
  if (clauseMatch) {
    parts.clause = clauseMatch[0];
  }

  return parts;
}
```

2. Create or update `lib/db/queries/index.ts` to export all query functions:

```typescript
// Topic queries
export {
  getDetailsByTopic,
  getTopicsWithCounts,
  getTopicById
} from './topics';

// Detail link queries
export {
  getDetailWithLinks,
  createDetailLink,
  getLinksForDetail,
  deleteDetailLink,
  type DetailWithLinks,
  type LinkedDetail,
  type LinkType,
  type MatchConfidence
} from './detail-links';
```
  </action>
  <verify>
TypeScript compiles for both files.
Exports from lib/db/queries/index.ts can be imported.
formatNZBCCitation({ code: 'E2/AS1', edition: '4th', clause: 'Table 20' }) returns "E2/AS1 (4th edition) Table 20"
  </verify>
  <done>
NZBC citation formatting utility created.
Query functions exported through central index.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. All files compile: `npx tsc --noEmit`
2. Query functions can be imported from lib/db/queries
3. getDetailsByTopic returns correct structure with source information
4. getDetailWithLinks returns bidirectional link data
5. formatNZBCCitation produces correct output
</verification>

<success_criteria>
- getDetailsByTopic('flashings') returns details from both MRM and RANZ sources
- getDetailsByTopic('flashings', { sourceId: 'mrm-cop' }) returns only MRM details
- getDetailWithLinks returns supplements and supplementsTo arrays
- formatNZBCCitation formats citations per NZBC standards (DATA-03)
- All functions are type-safe and exported properly
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-model-foundation/07-03-SUMMARY.md`
</output>
