---
phase: 30-content-composition-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/queries/encyclopedia-content.ts
  - lib/encyclopedia/article-composer.ts
  - types/encyclopedia.ts
autonomous: true

must_haves:
  truths:
    - "Article composer fetches HTG content text, installation details, and failure cases in parallel for a given chapter"
    - "HTG content query returns the actual content field (full text), not just guide name and source document"
    - "Failure cases query traverses cop_sections -> cop_section_details -> details -> detail_failure_links -> failure_cases"
    - "Parallel execution via Promise.all completes faster than sequential queries"
  artifacts:
    - path: "lib/db/queries/encyclopedia-content.ts"
      provides: "getHtgContentForChapter and getFailureCasesForChapter queries"
      exports: ["getHtgContentForChapter", "getFailureCasesForChapter"]
    - path: "lib/encyclopedia/article-composer.ts"
      provides: "composeArticleContent function orchestrating parallel data fetching"
      exports: ["composeArticleContent"]
    - path: "types/encyclopedia.ts"
      provides: "ComposedSupplementary, HtgGuidanceBlock, InlineCaseLaw types"
      contains: "ComposedSupplementary"
  key_links:
    - from: "lib/encyclopedia/article-composer.ts"
      to: "lib/db/queries/supplementary.ts"
      via: "imports getSupplementaryContent"
      pattern: "getSupplementaryContent"
    - from: "lib/encyclopedia/article-composer.ts"
      to: "lib/db/queries/encyclopedia-content.ts"
      via: "imports getHtgContentForChapter, getFailureCasesForChapter"
      pattern: "getHtgContentForChapter|getFailureCasesForChapter"
    - from: "lib/encyclopedia/article-composer.ts"
      to: "Promise.all"
      via: "parallel execution of 3 queries"
      pattern: "Promise\\.all"
---

<objective>
Create the article composition data layer that fetches content from multiple database sources in parallel (cop_sections, htg_content, details, failure_cases) and returns an enriched supplementary data structure for encyclopedia article rendering.

Purpose: Currently the chapter page only fetches detail links and HTG guide names (not content). This plan adds queries for actual HTG text content and failure cases, then orchestrates all fetches in parallel via a single composer function.

Output: `article-composer.ts` utility + `encyclopedia-content.ts` queries + enriched types
</objective>

<execution_context>
@C:/Users/LukeBoustridge/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/LukeBoustridge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-foundation-article-architecture/29-03-SUMMARY.md

Key files to reference:
@lib/db/queries/supplementary.ts - Existing supplementary query (details + HTG links)
@lib/db/schema.ts - Full Drizzle schema with all tables
@types/encyclopedia.ts - Existing encyclopedia types
@types/cop.ts - SupplementaryData, SupplementaryDetail, SupplementaryHtg types
@lib/db/queries/htg-guides.ts - Existing HTG query patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create encyclopedia content queries for HTG text and failure cases</name>
  <files>lib/db/queries/encyclopedia-content.ts</files>
  <action>
Create `lib/db/queries/encyclopedia-content.ts` with two new query functions:

**1. `getHtgContentForChapter(chapterNumber: number)`**
- Query path: copSectionHtg -> copSections (filter by chapterNumber) -> htgContent
- Select: sectionId (from copSections), htgContent.id, htgContent.guideName, htgContent.sourceDocument, htgContent.content (THE KEY FIELD - full text), htgContent.pdfPage, copSectionHtg.relevance
- Return: `Map<string, HtgGuidanceBlock[]>` keyed by section ID (e.g., "cop-8.5.4")
- Each HtgGuidanceBlock: `{ id, guideName, sourceDocument, content, pdfPage, relevance }`
- Deduplicate: same HTG guide can link to multiple sections, but within a section show each guide only once

**2. `getFailureCasesForChapter(chapterNumber: number)`**
- Query path: copSections (filter by chapterNumber) -> copSectionDetails -> details -> detailFailureLinks -> failureCases
- Select: sectionId (from copSections), failureCases.id, failureCases.caseId, failureCases.caseType, failureCases.summary, failureCases.outcome, failureCases.pdfUrl, failureCases.failureType
- Return: `Map<string, InlineCaseLaw[]>` keyed by section ID (e.g., "cop-8.5.4")
- Each InlineCaseLaw: `{ id, caseId, caseType, summary, outcome, pdfUrl, failureType }`
- Deduplicate: same failure case may link through multiple details in same section; show each case once per section

Import from `@/lib/db` and `@/lib/db/schema`. Use `eq` from drizzle-orm for joins. Follow the same Map-based grouping pattern as `getSupplementaryContent` in `lib/db/queries/supplementary.ts`.

Export the HtgGuidanceBlock and InlineCaseLaw interfaces from this file (they'll also be added to types/encyclopedia.ts in Task 2).
  </action>
  <verify>
`npx tsc --noEmit` passes with the new file. Both functions are importable and type-correct. Verify the join chain is valid against the schema (copSections -> copSectionDetails -> details -> detailFailureLinks -> failureCases).
  </verify>
  <done>
Two query functions exist that fetch: (1) full HTG content text for all sections in a chapter, and (2) failure cases linked through details to COP sections in a chapter. Both return Map<string, T[]> keyed by section ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create article composer with parallel data fetching and enriched types</name>
  <files>lib/encyclopedia/article-composer.ts, types/encyclopedia.ts</files>
  <action>
**Step 1: Add types to `types/encyclopedia.ts`**

Add the following interfaces (append after existing EncyclopediaArticle interface):

```typescript
/** HTG guide content block for inline "Practical Guidance" rendering */
export interface HtgGuidanceBlock {
  id: string;
  guideName: string;
  sourceDocument: string;
  content: string | null;
  pdfPage: number | null;
  relevance: string | null;
}

/** Failure case for inline case law callout rendering */
export interface InlineCaseLaw {
  id: string;
  caseId: string;
  caseType: string;
  summary: string | null;
  outcome: string | null;
  pdfUrl: string | null;
  failureType: string | null;
}

/** Composed supplementary content for a single COP section */
export interface ComposedSupplementary {
  details: import('@/types/cop').SupplementaryDetail[];
  htgGuides: import('@/types/cop').SupplementaryHtg[];
  htgContent: HtgGuidanceBlock[];
  caseLaw: InlineCaseLaw[];
}
```

**Step 2: Create `lib/encyclopedia/article-composer.ts`**

```typescript
import { getSupplementaryContent } from '@/lib/db/queries/supplementary';
import { getHtgContentForChapter, getFailureCasesForChapter } from '@/lib/db/queries/encyclopedia-content';
import type { ComposedSupplementary } from '@/types/encyclopedia';

/**
 * Composes article content by fetching from multiple sources in parallel.
 *
 * Sources:
 * 1. Supplementary details + HTG guide links (existing query)
 * 2. HTG full text content (new query)
 * 3. Failure cases via detail links (new query)
 *
 * Returns a Record<string, ComposedSupplementary> keyed by section ID
 * for efficient lookup during article rendering.
 */
export async function composeArticleContent(
  chapterNumber: number
): Promise<Record<string, ComposedSupplementary>> {
  // Parallel fetch from all three sources
  const [supplementaryMap, htgContentMap, caseLawMap] = await Promise.all([
    getSupplementaryContent(chapterNumber),
    getHtgContentForChapter(chapterNumber),
    getFailureCasesForChapter(chapterNumber),
  ]);

  // Merge all sources into a single Record keyed by section ID
  const allSectionIds = new Set<string>([
    ...supplementaryMap.keys(),
    ...htgContentMap.keys(),
    ...caseLawMap.keys(),
  ]);

  const composed: Record<string, ComposedSupplementary> = {};

  for (const sectionId of allSectionIds) {
    const supplementary = supplementaryMap.get(sectionId);
    composed[sectionId] = {
      details: supplementary?.details ?? [],
      htgGuides: supplementary?.htgGuides ?? [],
      htgContent: htgContentMap.get(sectionId) ?? [],
      caseLaw: caseLawMap.get(sectionId) ?? [],
    };
  }

  return composed;
}
```

Key design notes:
- Returns Record (not Map) because it will be serialized to client components (Maps don't serialize)
- Merges union of all section IDs so no data is lost
- Each field has a sensible empty-array default
- The existing `getSupplementaryContent` is reused as-is (no duplication)
- Promise.all ensures all 3 queries run in parallel
  </action>
  <verify>
`npm run build` passes. Import `composeArticleContent` in a test import and verify the return type includes `details`, `htgGuides`, `htgContent`, and `caseLaw` fields. Verify `types/encyclopedia.ts` exports all new interfaces.
  </verify>
  <done>
Article composer function exists at `lib/encyclopedia/article-composer.ts` that orchestrates parallel fetching of supplementary details, HTG full-text content, and failure cases. Returns a single Record<string, ComposedSupplementary> for efficient per-section lookup. Types are defined in `types/encyclopedia.ts`.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with 0 errors
2. `lib/db/queries/encyclopedia-content.ts` exports `getHtgContentForChapter` and `getFailureCasesForChapter`
3. `lib/encyclopedia/article-composer.ts` exports `composeArticleContent`
4. `types/encyclopedia.ts` includes `HtgGuidanceBlock`, `InlineCaseLaw`, `ComposedSupplementary` interfaces
5. Article composer uses `Promise.all` for parallel query execution
6. HTG content query selects the `content` field (full text) from htgContent table
7. Failure cases query traverses the full join chain: copSections -> copSectionDetails -> details -> detailFailureLinks -> failureCases
</verification>

<success_criteria>
- Article composer can fetch and merge data from 3 parallel queries for any chapter number
- HTG full-text content is available per section (not just guide names/links)
- Failure cases are available per section (traversed through detail links)
- Return type is a serializable Record (not Map) with all 4 content categories per section
- Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/30-content-composition-engine/30-01-SUMMARY.md`
</output>
