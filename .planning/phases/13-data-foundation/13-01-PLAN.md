# Plan 13-01: Database Schema and COP Hierarchy Import

**Phase:** 13 - Data Foundation
**Estimated complexity:** High
**Requirements addressed:** COPR-01, COPR-02

## Goal

Create 5 new database tables for COP structure and populate with 19 chapters, 800-1,100 sections, and 775 image mappings from extracted JSON data.

## Pre-conditions

- Drizzle ORM configured with Neon PostgreSQL
- `mrm_extract/` directory exists with extracted JSON files:
  - `sections_hierarchy.json` (11,392 lines)
  - `images_manifest.json` (9,933 lines)
  - `r2_image_urls.json`
  - `metadata.json`
- Existing migrations in `lib/db/migrations/` (0000-0004)
- `content_sources` table already exists with 'mrm-cop' source

## Tasks

### Task 1: Add COP schema tables to Drizzle schema
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\lib\db\schema.ts`
**Action:** Modify
**Details:**

Add 5 new table definitions at the end of the schema file, following existing patterns:

```typescript
// ============================================
// COP SECTIONS (MRM Code of Practice hierarchy)
// ============================================
export const copSections = pgTable('cop_sections', {
  id: text('id').primaryKey(),              // e.g., 'cop-8.5.4A'
  sectionNumber: text('section_number').notNull().unique(), // '8.5.4A'
  chapterNumber: integer('chapter_number').notNull(), // 8
  parentId: text('parent_id'),              // 'cop-8.5.4' (self-ref, nullable)
  title: text('title').notNull(),
  level: integer('level').notNull(),        // 1=chapter, 2=section, 3=subsection, 4=variant
  sortOrder: integer('sort_order').notNull(), // For display order
  pdfPages: jsonb('pdf_pages').$type<number[]>(), // [78, 79]
  hasContent: boolean('has_content').default(false),
  sourceId: text('source_id').references(() => contentSources.id).default('mrm-cop'),
  createdAt: timestamp('created_at').defaultNow(),
}, (table) => ({
  chapterIdx: index('idx_cop_sections_chapter').on(table.chapterNumber),
  parentIdx: index('idx_cop_sections_parent').on(table.parentId),
  sectionNumberIdx: index('idx_cop_sections_number').on(table.sectionNumber),
}));

// ============================================
// COP SECTION IMAGES (image-to-section mapping)
// ============================================
export const copSectionImages = pgTable('cop_section_images', {
  id: text('id').primaryKey(),              // e.g., 'img-section-detail-394'
  sectionId: text('section_id').references(() => copSections.id, { onDelete: 'cascade' }).notNull(),
  imageFilename: text('image_filename').notNull(), // 'section-detail-394.png'
  imageUrl: text('image_url').notNull(),     // R2 URL
  caption: text('caption'),
  imageType: text('image_type'),             // 'technical_diagram'
  sortOrder: integer('sort_order').default(0),
  dimensions: jsonb('dimensions').$type<{width: number; height: number}>(),
}, (table) => ({
  sectionIdx: index('idx_cop_section_images_section').on(table.sectionId),
  filenameIdx: index('idx_cop_section_images_filename').on(table.imageFilename),
}));

// ============================================
// COP SECTION DETAILS (links COP sections to existing detail records)
// ============================================
export const copSectionDetails = pgTable('cop_section_details', {
  sectionId: text('section_id').references(() => copSections.id, { onDelete: 'cascade' }).notNull(),
  detailId: text('detail_id').references(() => details.id, { onDelete: 'cascade' }).notNull(),
  relationshipType: text('relationship_type').notNull(), // 'referenced', 'illustrates', 'alternative'
  notes: text('notes'),
}, (table) => ({
  pk: primaryKey({ columns: [table.sectionId, table.detailId] }),
  sectionIdx: index('idx_cop_section_details_section').on(table.sectionId),
  detailIdx: index('idx_cop_section_details_detail').on(table.detailId),
}));

// ============================================
// HTG CONTENT (How-To Guides extracted from HTG PDFs)
// ============================================
export const htgContent = pgTable('htg_content', {
  id: text('id').primaryKey(),              // e.g., 'htg-flashings-001'
  sourceDocument: text('source_document').notNull(), // 'HTG Flashings.pdf'
  guideName: text('guide_name').notNull(),
  content: text('content'),                  // Plain text extraction
  images: jsonb('images').$type<string[]>(), // R2 URLs for HTG images
  pdfPage: integer('pdf_page'),
  createdAt: timestamp('created_at').defaultNow(),
}, (table) => ({
  sourceIdx: index('idx_htg_content_source').on(table.sourceDocument),
}));

// ============================================
// COP SECTION HTG (links COP sections to HTG guides)
// ============================================
export const copSectionHtg = pgTable('cop_section_htg', {
  sectionId: text('section_id').references(() => copSections.id, { onDelete: 'cascade' }).notNull(),
  htgId: text('htg_id').references(() => htgContent.id, { onDelete: 'cascade' }).notNull(),
  relevance: text('relevance'),              // 'primary', 'supplementary'
  notes: text('notes'),
}, (table) => ({
  pk: primaryKey({ columns: [table.sectionId, table.htgId] }),
}));
```

**Rationale:**
- Use text-based IDs (`cop-8.5.4A`) matching existing schema patterns for readable URLs
- Use `jsonb` for array fields (pdfPages, images) matching existing pattern
- Use `timestamp('created_at').defaultNow()` matching existing pattern
- Self-referential `parentId` allows hierarchical queries with recursive CTEs
- Indexes on `chapterNumber`, `parentId`, `sectionNumber` for navigation performance
- `htg_content` and `cop_section_htg` tables created as empty structures (populated in Phase 17)

### Task 2: Generate and apply migration
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\lib\db\migrations\`
**Action:** Create
**Details:**

1. Generate migration from updated schema:
```bash
npm run db:generate
```

This will create a new migration file like `0005_cop_tables.sql` in `lib/db/migrations/`.

2. Review the generated migration to ensure it includes:
   - 5 CREATE TABLE statements
   - All column definitions with correct types
   - PRIMARY KEY and FOREIGN KEY constraints
   - All indexes (8 indexes total)

3. Apply migration to Neon database:
```bash
npm run db:push
```

**Expected output:**
```
Applying migration: 0005_cop_tables.sql
✓ Created table cop_sections
✓ Created table cop_section_images
✓ Created table cop_section_details
✓ Created table htg_content
✓ Created table cop_section_htg
✓ Created 8 indexes
Migration complete!
```

### Task 3: Create COP hierarchy import script
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\lib\db\import-cop-hierarchy.ts`
**Action:** Create
**Details:**

Create import script that reads `sections_hierarchy.json` and populates `cop_sections` table:

```typescript
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import { copSections } from './schema';
import * as fs from 'fs';
import * as path from 'path';
import { config } from 'dotenv';

config({ path: '.env.local' });

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);

interface SectionNode {
  number: string;
  title: string;
  content: string;
  pdf_pages: number[];
  subsections: Record<string, SectionNode>;
}

type SectionsData = Record<string, SectionNode>;

async function importSection(
  chapterNum: number,
  sectionNum: string,
  node: SectionNode,
  parentId: string | null,
  level: number,
  order: number
): Promise<number> {
  const sectionId = `cop-${sectionNum}`;

  await db.insert(copSections).values({
    id: sectionId,
    sectionNumber: sectionNum,
    chapterNumber: chapterNum,
    parentId,
    title: node.title,
    level,
    sortOrder: order,
    pdfPages: node.pdf_pages,
    hasContent: node.content.length > 0,
    sourceId: 'mrm-cop',
  });

  console.log(`  Imported: ${sectionNum} - ${node.title} (level ${level}, order ${order})`);

  // Import subsections recursively
  let childOrder = order * 1000; // Leave room for siblings
  for (const [subNum, subNode] of Object.entries(node.subsections)) {
    childOrder = await importSection(
      chapterNum,
      subNum,
      subNode,
      sectionId,
      level + 1,
      childOrder + 1
    );
  }

  return childOrder;
}

async function importCopHierarchy() {
  console.log('Starting COP hierarchy import...\n');

  // Load sections hierarchy JSON
  const sectionsPath = path.join(process.cwd(), 'mrm_extract', 'sections_hierarchy.json');
  const sectionsData: SectionsData = JSON.parse(fs.readFileSync(sectionsPath, 'utf-8'));

  console.log(`Loaded sections_hierarchy.json (${Object.keys(sectionsData).length} chapters)\n`);

  // Clear existing COP sections (cascade will handle related records)
  console.log('Clearing existing COP sections...');
  await db.delete(copSections);
  console.log('Existing COP sections cleared\n');

  // Import chapters (top-level keys are chapter numbers: "1", "2", "3", ...)
  const chapters = Object.entries(sectionsData).sort(([a], [b]) => parseInt(a) - parseInt(b));

  let totalSections = 0;

  for (const [chNum, chapter] of chapters) {
    const chapterNumber = parseInt(chNum);
    console.log(`\nImporting Chapter ${chapterNumber}: ${chapter.title}`);

    await importSection(
      chapterNumber,
      chNum,
      chapter,
      null,
      1,
      chapterNumber * 1000
    );

    // Count sections in this chapter
    const countSections = (node: SectionNode): number => {
      let count = 1;
      for (const sub of Object.values(node.subsections)) {
        count += countSections(sub);
      }
      return count;
    };

    const chapterSections = countSections(chapter);
    totalSections += chapterSections;
    console.log(`  Chapter ${chapterNumber} complete: ${chapterSections} sections`);
  }

  console.log(`\n✓ Import complete!`);
  console.log(`  Total chapters: ${chapters.length}`);
  console.log(`  Total sections: ${totalSections}`);
}

importCopHierarchy()
  .then(() => {
    console.log('\nCOP hierarchy import completed successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Import failed:', error);
    process.exit(1);
  });
```

**Key implementation details:**
- Recursive import function handles arbitrary hierarchy depth (1-4 levels observed in data)
- Sort order uses multiplier strategy (chapter × 1000, subsection × 1000 of parent) to allow insertion order without conflicts
- `hasContent` flag based on non-empty content field (enables filtering empty structural sections)
- Console logging tracks progress per section for debugging
- Clears existing data before import (idempotent for re-runs)

### Task 4: Create COP images import script
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\lib\db\import-cop-images.ts`
**Action:** Create
**Details:**

Create import script that reads `images_manifest.json` and `r2_image_urls.json` to populate `cop_section_images` table:

```typescript
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import { copSectionImages } from './schema';
import * as fs from 'fs';
import * as path from 'path';
import { config } from 'dotenv';

config({ path: '.env.local' });

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);

interface ImageManifestEntry {
  filename: string;
  source_page: number;
  detail_codes: string[];
  caption: string;
  type: string;
  dimensions: {
    width: number;
    height: number;
  };
  section: string | null; // COP section number like "8.5.4" or null
}

type ImagesManifest = Record<string, ImageManifestEntry>;
type R2UrlMap = Record<string, string>;

async function importCopImages() {
  console.log('Starting COP images import...\n');

  // Load images manifest and R2 URLs
  const manifestPath = path.join(process.cwd(), 'mrm_extract', 'images_manifest.json');
  const r2UrlsPath = path.join(process.cwd(), 'mrm_extract', 'r2_image_urls.json');

  const imagesManifest: ImagesManifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
  const r2UrlMap: R2UrlMap = JSON.parse(fs.readFileSync(r2UrlsPath, 'utf-8'));

  const allImages = Object.values(imagesManifest);
  const mappedImages = allImages.filter(img => img.section !== null);
  const unmappedImages = allImages.filter(img => img.section === null);

  console.log(`Loaded images_manifest.json (${allImages.length} images)`);
  console.log(`  - ${mappedImages.length} with section mapping`);
  console.log(`  - ${unmappedImages.length} without section mapping\n`);

  // Clear existing COP images
  console.log('Clearing existing COP images...');
  await db.delete(copSectionImages);
  console.log('Existing COP images cleared\n');

  // Import images with section mappings
  const imagesToImport = [];
  let skippedNoUrl = 0;
  let skippedNoSection = 0;

  for (const [filename, img] of Object.entries(imagesManifest)) {
    if (!img.section) {
      skippedNoSection++;
      continue;
    }

    const r2Url = r2UrlMap[filename];
    if (!r2Url) {
      console.warn(`  Warning: No R2 URL for ${filename}`);
      skippedNoUrl++;
      continue;
    }

    // Convert section number to section ID
    const sectionId = `cop-${img.section}`;

    imagesToImport.push({
      id: `img-${filename.replace('.png', '')}`,
      sectionId,
      imageFilename: filename,
      imageUrl: r2Url,
      caption: img.caption || null,
      imageType: img.type,
      sortOrder: 0,
      dimensions: img.dimensions,
    });
  }

  console.log(`Importing ${imagesToImport.length} images...\n`);

  // Batch insert (50 at a time)
  const BATCH_SIZE = 50;
  for (let i = 0; i < imagesToImport.length; i += BATCH_SIZE) {
    const batch = imagesToImport.slice(i, i + BATCH_SIZE);
    await db.insert(copSectionImages).values(batch);
    console.log(`  Inserted images ${i + 1}-${Math.min(i + BATCH_SIZE, imagesToImport.length)} of ${imagesToImport.length}`);
  }

  console.log(`\n✓ Import complete!`);
  console.log(`  Total images imported: ${imagesToImport.length}`);
  console.log(`  Skipped (no section): ${skippedNoSection}`);
  console.log(`  Skipped (no R2 URL): ${skippedNoUrl}`);

  if (unmappedImages.length > 0) {
    console.log(`\nNote: ${unmappedImages.length} unmapped images not imported (likely cover/frontmatter)`);
  }
}

importCopImages()
  .then(() => {
    console.log('\nCOP images import completed successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Import failed:', error);
    process.exit(1);
  });
```

**Key implementation details:**
- Filters images where `section` field is null (3 images from manifest - likely cover/frontmatter)
- Maps filename to R2 URL from `r2_image_urls.json`
- Converts section number (e.g., "8.5.4") to section ID (e.g., "cop-8.5.4") for foreign key
- Batch inserts (50 at a time) for performance
- Reports skipped images (no section or no R2 URL) for validation

### Task 5: Add import scripts to package.json
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\package.json`
**Action:** Modify
**Details:**

Add two new script entries to the `scripts` section:

```json
"db:import-cop-hierarchy": "npx tsx lib/db/import-cop-hierarchy.ts",
"db:import-cop-images": "npx tsx lib/db/import-cop-images.ts"
```

Place these after the existing `db:import-ranz` script (around line 21).

### Task 6: Run hierarchy import
**File:** N/A (command execution)
**Action:** Execute
**Details:**

Run the hierarchy import script:

```bash
npm run db:import-cop-hierarchy
```

**Expected console output:**
```
Starting COP hierarchy import...

Loaded sections_hierarchy.json (19 chapters)

Clearing existing COP sections...
Existing COP sections cleared

Importing Chapter 1: Introduction
  Imported: 1 - Introduction (level 1, order 1000)
  Imported: 1.1 - Disclaimer and Copyright (level 2, order 1001)
  Imported: 1.1.1 - Code of Practice Update-Policy (level 3, order 1002)
  ...
  Chapter 1 complete: 12 sections

Importing Chapter 2: Glossary
  ...

...

Importing Chapter 19: Revision History
  ...
  Chapter 19 complete: 143 sections

✓ Import complete!
  Total chapters: 19
  Total sections: 1122

COP hierarchy import completed successfully!
```

**Validation:** Verify total sections is between 800-1,122 (expected range from research).

### Task 7: Run images import
**File:** N/A (command execution)
**Action:** Execute
**Details:**

Run the images import script:

```bash
npm run db:import-cop-images
```

**Expected console output:**
```
Starting COP images import...

Loaded images_manifest.json (775 images)
  - 772 with section mapping
  - 3 without section mapping

Clearing existing COP images...
Existing COP images cleared

Importing 772 images...

  Inserted images 1-50 of 772
  Inserted images 51-100 of 772
  ...
  Inserted images 751-772 of 772

✓ Import complete!
  Total images imported: 772
  Skipped (no section): 3
  Skipped (no R2 URL): 0

Note: 3 unmapped images not imported (likely cover/frontmatter)

COP images import completed successfully!
```

**Validation:** Verify 772 images imported (expected from research - 775 total minus 3 unmapped).

## Verification

### Database verification
Run these SQL queries via Drizzle Studio or direct connection:

```sql
-- Verify all 5 tables created
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN ('cop_sections', 'cop_section_images', 'cop_section_details', 'htg_content', 'cop_section_htg');
-- Expected: 5 rows

-- Verify cop_sections populated
SELECT
  COUNT(*) as total_sections,
  COUNT(DISTINCT chapter_number) as chapters,
  MIN(level) as min_level,
  MAX(level) as max_level
FROM cop_sections;
-- Expected: total_sections between 800-1122, chapters=19, min_level=1, max_level=4

-- Verify section hierarchy (spot check Chapter 8)
SELECT id, section_number, parent_id, title, level
FROM cop_sections
WHERE chapter_number = 8
ORDER BY sort_order
LIMIT 10;
-- Should show Chapter 8 root, then subsections like 8.1, 8.1.1, etc.

-- Verify cop_section_images populated
SELECT
  COUNT(*) as total_images,
  COUNT(DISTINCT section_id) as sections_with_images
FROM cop_section_images;
-- Expected: total_images=772, sections_with_images should be high (many sections have images)

-- Verify image-section relationship
SELECT s.section_number, s.title, COUNT(i.id) as image_count
FROM cop_sections s
JOIN cop_section_images i ON i.section_id = s.id
WHERE s.chapter_number = 8
GROUP BY s.id, s.section_number, s.title
ORDER BY s.sort_order
LIMIT 5;
-- Should show sections from Chapter 8 with their image counts

-- Verify htg_content and cop_section_htg are empty (populated in Phase 17)
SELECT COUNT(*) FROM htg_content;
-- Expected: 0

SELECT COUNT(*) FROM cop_section_htg;
-- Expected: 0

-- Verify cop_section_details is empty (populated in Plan 13-02)
SELECT COUNT(*) FROM cop_section_details;
-- Expected: 0
```

### Drizzle Studio verification
1. Run `npm run db:studio`
2. Open browser to Drizzle Studio URL
3. Navigate to `cop_sections` table
4. Verify:
   - 19 chapter-level records (level=1)
   - Hierarchy visible in parent_id relationships
   - Section numbers match expected format (1, 1.1, 1.1.1, 8.5.4A, etc.)
5. Navigate to `cop_section_images` table
6. Verify:
   - 772 records
   - `imageUrl` field contains valid R2 URLs (starts with https://pub-)
   - `dimensions` field contains width/height objects

### File system verification
```bash
# Verify migration file created
ls lib/db/migrations/ | grep "cop_tables"
# Expected: one .sql file with timestamp prefix

# Verify import scripts created
ls lib/db/import-cop-*.ts
# Expected: import-cop-hierarchy.ts, import-cop-images.ts
```

## Notes

**Section number format variations:**
- Chapters: "1", "2", "19"
- Sections: "1.1", "8.5", "19.1"
- Subsections: "1.1.1", "8.5.4", "19.1.1"
- Variants: "8.5.4A", "3.9.1B" (letter suffix for diagram/table variations)

All handled by text-based `section_number` field with no parsing required.

**Images without section mapping:**
Research identified 3 of 775 images have `"section": null` in manifest. These are intentionally skipped (likely cover page, frontmatter, or unattributable diagrams). If needed later, create a special section `cop-0-frontmatter` for these.

**HTG tables empty by design:**
`htg_content` and `cop_section_htg` tables are created as empty structures in this plan. They will be populated in Phase 17 (HTG Content Pipeline) after HTG PDF extraction. This separation keeps Phase 13 focused on COP hierarchy only.

**Detail linking deferred:**
`cop_section_details` table is created empty. Population happens in Plan 13-02 after per-chapter JSON files exist (needed to identify section-detail relationships from content).

**Re-running imports:**
Both import scripts are idempotent. They clear existing data before import, so re-running is safe for development/testing. In production, consider adding a confirmation prompt.

**Performance:**
- Section import: ~2-3 minutes for 1,122 sections (recursive inserts, single transaction would be faster but less debuggable)
- Image import: ~15-20 seconds for 772 images (batch inserts of 50)

**Migration rollback:**
If needed, rollback via Drizzle Kit:
```bash
# Check applied migrations
npx drizzle-kit status

# Rollback one migration
npx drizzle-kit drop
```
