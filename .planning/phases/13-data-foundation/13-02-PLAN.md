# Plan 13-02: Chapter JSON Split and Section-Detail Linking

**Phase:** 13 - Data Foundation
**Estimated complexity:** Medium
**Requirements addressed:** COPR-04

## Goal

Split `sections_hierarchy.json` into 19 per-chapter JSON files in `/public/cop/` with embedded image URLs, and link COP sections to existing detail records where applicable.

## Pre-conditions

- Plan 13-01 complete (5 tables created and populated)
- `cop_sections` table populated with ~1,122 sections
- `cop_section_images` table populated with 772 images
- `details` table populated with existing MRM detail records
- `sections_hierarchy.json`, `images_manifest.json`, `r2_image_urls.json` exist in `mrm_extract/`

## Tasks

### Task 1: Create per-chapter JSON generator script
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\lib\db\split-chapter-json.ts`
**Action:** Create
**Details:**

Create script that reads `sections_hierarchy.json` and splits into per-chapter files:

```typescript
import * as fs from 'fs';
import * as path from 'path';

interface SectionNode {
  number: string;
  title: string;
  content: string;
  pdf_pages: number[];
  subsections: Record<string, SectionNode>;
}

type SectionsData = Record<string, SectionNode>;

interface ImageManifestEntry {
  filename: string;
  source_page: number;
  detail_codes: string[];
  caption: string;
  type: string;
  dimensions: {
    width: number;
    height: number;
  };
  section: string | null;
}

type ImagesManifest = Record<string, ImageManifestEntry>;
type R2UrlMap = Record<string, string>;

interface ChapterImage {
  filename: string;
  url: string;
  caption: string;
  dimensions: { width: number; height: number };
}

interface ChapterSection {
  number: string;
  title: string;
  level: number;
  content: string;
  pdfPages: number[];
  images?: ChapterImage[];
  subsections?: ChapterSection[];
}

interface ChapterJSON {
  chapterNumber: number;
  title: string;
  version: string;
  sectionCount: number;
  sections: ChapterSection[];
}

// Load data files
const sectionsPath = path.join(process.cwd(), 'mrm_extract', 'sections_hierarchy.json');
const manifestPath = path.join(process.cwd(), 'mrm_extract', 'images_manifest.json');
const r2UrlsPath = path.join(process.cwd(), 'mrm_extract', 'r2_image_urls.json');
const metadataPath = path.join(process.cwd(), 'mrm_extract', 'metadata.json');

const sectionsData: SectionsData = JSON.parse(fs.readFileSync(sectionsPath, 'utf-8'));
const imagesManifest: ImagesManifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
const r2UrlMap: R2UrlMap = JSON.parse(fs.readFileSync(r2UrlsPath, 'utf-8'));
const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));

/**
 * Find images for a specific section number
 */
function findImagesForSection(sectionNum: string): ChapterImage[] {
  const images: ChapterImage[] = [];

  for (const [filename, img] of Object.entries(imagesManifest)) {
    if (img.section === sectionNum) {
      const url = r2UrlMap[filename];
      if (url) {
        images.push({
          filename,
          url,
          caption: img.caption || '',
          dimensions: img.dimensions,
        });
      }
    }
  }

  return images;
}

/**
 * Recursively build chapter section structure with images
 */
function buildSection(sectionNum: string, node: SectionNode, level: number): ChapterSection {
  const images = findImagesForSection(sectionNum);

  const section: ChapterSection = {
    number: sectionNum,
    title: node.title,
    level,
    content: node.content,
    pdfPages: node.pdf_pages,
  };

  // Only add images array if there are images
  if (images.length > 0) {
    section.images = images;
  }

  // Recursively build subsections
  const subsections = Object.entries(node.subsections || {}).map(([subNum, subNode]) =>
    buildSection(subNum, subNode, level + 1)
  );

  // Only add subsections array if there are subsections
  if (subsections.length > 0) {
    section.subsections = subsections;
  }

  return section;
}

/**
 * Count total sections in a chapter (recursive)
 */
function countSections(node: SectionNode): number {
  let count = 1;
  for (const sub of Object.values(node.subsections || {})) {
    count += countSections(sub);
  }
  return count;
}

/**
 * Generate per-chapter JSON files
 */
function splitChapterJson() {
  console.log('Starting chapter JSON split...\n');
  console.log(`Source version: ${metadata.version}`);
  console.log(`Total chapters: ${Object.keys(sectionsData).length}\n`);

  // Create output directory
  const outDir = path.join(process.cwd(), 'public', 'cop');
  fs.mkdirSync(outDir, { recursive: true });
  console.log(`Output directory: ${outDir}\n`);

  // Process each chapter
  const chapters = Object.entries(sectionsData).sort(([a], [b]) => parseInt(a) - parseInt(b));
  const fileSizes: Array<{ chapter: number; size: number; sizeKB: number }> = [];

  for (const [chNum, chapter] of chapters) {
    const chapterNumber = parseInt(chNum);
    const sectionCount = countSections(chapter);

    console.log(`Processing Chapter ${chapterNumber}: ${chapter.title}`);
    console.log(`  Sections: ${sectionCount}`);

    const chapterJSON: ChapterJSON = {
      chapterNumber,
      title: chapter.title,
      version: metadata.version,
      sectionCount,
      sections: [buildSection(chNum, chapter, 1)],
    };

    // Write minified JSON (not pretty-printed) for production
    const outputPath = path.join(outDir, `chapter-${chapterNumber}.json`);
    const jsonString = JSON.stringify(chapterJSON);
    fs.writeFileSync(outputPath, jsonString, 'utf-8');

    const sizeBytes = Buffer.byteLength(jsonString, 'utf-8');
    const sizeKB = Math.round(sizeBytes / 1024);
    fileSizes.push({ chapter: chapterNumber, size: sizeBytes, sizeKB });

    console.log(`  Output: chapter-${chapterNumber}.json (${sizeKB} KB uncompressed)\n`);
  }

  console.log('✓ Split complete!\n');
  console.log('File sizes:');

  fileSizes.sort((a, b) => b.size - a.size);

  for (const { chapter, sizeKB } of fileSizes) {
    const bar = '█'.repeat(Math.ceil(sizeKB / 10));
    console.log(`  Chapter ${chapter.toString().padStart(2)}: ${sizeKB.toString().padStart(4)} KB ${bar}`);
  }

  const totalKB = fileSizes.reduce((sum, f) => sum + f.sizeKB, 0);
  const avgKB = Math.round(totalKB / fileSizes.length);
  const maxKB = fileSizes[0].sizeKB;

  console.log(`\n  Total: ${totalKB} KB`);
  console.log(`  Average: ${avgKB} KB`);
  console.log(`  Largest: Chapter ${fileSizes[0].chapter} (${maxKB} KB)`);

  if (maxKB > 200) {
    console.log(`\n⚠ Warning: Chapter ${fileSizes[0].chapter} exceeds 200KB uncompressed`);
    console.log(`  This may exceed 100KB compressed target on mobile`);
    console.log(`  Consider splitting large chapters or paginating content`);
  }
}

splitChapterJson();
```

**Key implementation details:**
- Outputs minified JSON (no pretty-printing) for production size optimization
- Embeds R2 image URLs directly in chapter JSON (avoids additional API calls)
- Only includes `images` and `subsections` arrays if non-empty (reduces file size)
- Reports file sizes with visual bar chart for quick identification of large chapters
- Warns if any chapter exceeds 200KB uncompressed (likely to exceed 100KB compressed target)

### Task 2: Add split script to package.json
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\package.json`
**Action:** Modify
**Details:**

Add new script entry:

```json
"db:split-chapter-json": "npx tsx lib/db/split-chapter-json.ts"
```

Place after the `db:import-cop-images` script added in Plan 13-01.

### Task 3: Run chapter split script
**File:** N/A (command execution)
**Action:** Execute
**Details:**

Run the split script:

```bash
npm run db:split-chapter-json
```

**Expected console output:**
```
Starting chapter JSON split...

Source version: v25.12
Total chapters: 19

Output directory: C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\public\cop

Processing Chapter 1: Introduction
  Sections: 12
  Output: chapter-1.json (56 KB uncompressed)

Processing Chapter 2: Glossary
  Sections: 87
  Output: chapter-2.json (213 KB uncompressed)

...

Processing Chapter 8: Flashings
  Sections: 92
  Output: chapter-8.json (281 KB uncompressed)

...

Processing Chapter 19: Revision History
  Sections: 143
  Output: chapter-19.json (619 KB uncompressed)

✓ Split complete!

File sizes:
  Chapter 19:  619 KB ████████████████████████████████████████████████████████████████
  Chapter  8:  281 KB ████████████████████████████████
  Chapter  2:  213 KB █████████████████████████
  ...

  Total: 3985 KB
  Average: 209 KB
  Largest: Chapter 19 (619 KB)

⚠ Warning: Chapter 19 exceeds 200KB uncompressed
  This may exceed 100KB compressed target on mobile
  Consider splitting large chapters or paginating content
```

**Note:** Warning about Chapter 19 (Revision History) is expected. This is documented in research as a known issue. Address in future optimization if mobile performance testing shows impact.

### Task 4: Verify chapter JSON files
**File:** N/A (file system verification)
**Action:** Verify
**Details:**

```bash
# Verify all 19 files created
ls public/cop/chapter-*.json | wc -l
# Expected: 19

# Check file sizes
ls -lh public/cop/

# Spot check a small chapter (Chapter 1)
cat public/cop/chapter-1.json | head -c 500
# Should show minified JSON starting with {"chapterNumber":1,"title":"Introduction",...

# Spot check a chapter with images (Chapter 8 - Flashings)
cat public/cop/chapter-8.json | grep -o '"images"' | wc -l
# Should show multiple occurrences (Chapter 8 has many diagram images)

# Verify R2 URLs embedded
cat public/cop/chapter-8.json | grep -o 'https://pub-.*\.r2\.dev' | head -3
# Should show 3 R2 URLs
```

### Task 5: Create section-detail linking script
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\lib\db\link-cop-section-details.ts`
**Action:** Create
**Details:**

Create script that analyzes COP section content and links to existing detail records where applicable:

```typescript
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import { copSections, details, copSectionDetails } from './schema';
import { config } from 'dotenv';
import { eq } from 'drizzle-orm';
import * as fs from 'fs';
import * as path from 'path';

config({ path: '.env.local' });

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);

interface ChapterJSON {
  chapterNumber: number;
  sections: Array<{
    number: string;
    content: string;
    subsections?: any[];
  }>;
}

/**
 * Extract all section numbers and content from chapter JSON (recursive)
 */
function extractSectionsFromChapter(sections: any[]): Array<{ number: string; content: string }> {
  const result: Array<{ number: string; content: string }> = [];

  for (const section of sections) {
    result.push({ number: section.number, content: section.content });

    if (section.subsections) {
      result.push(...extractSectionsFromChapter(section.subsections));
    }
  }

  return result;
}

/**
 * Find detail code references in section content
 * Looks for patterns like "F07", "P12", "D03" (common MRM detail codes)
 */
function findDetailReferences(content: string): string[] {
  const detailCodePattern = /\b([A-Z]\d{2,3})\b/g;
  const matches = content.match(detailCodePattern) || [];

  // Remove duplicates
  return [...new Set(matches)];
}

/**
 * Link COP sections to detail records
 */
async function linkCopSectionDetails() {
  console.log('Starting section-detail linking...\n');

  // Load all existing details
  console.log('Loading existing details...');
  const existingDetails = await db.select({ code: details.code, id: details.id }).from(details);
  const detailCodeMap = new Map(existingDetails.map(d => [d.code, d.id]));
  console.log(`Loaded ${existingDetails.size} existing details\n`);

  // Clear existing links
  console.log('Clearing existing section-detail links...');
  await db.delete(copSectionDetails);
  console.log('Existing links cleared\n');

  const linksToCreate: Array<{
    sectionId: string;
    detailId: string;
    relationshipType: string;
    notes: string | null;
  }> = [];

  // Process each chapter JSON file
  const copDir = path.join(process.cwd(), 'public', 'cop');
  const chapterFiles = fs.readdirSync(copDir).filter(f => f.startsWith('chapter-'));

  console.log(`Processing ${chapterFiles.length} chapter files...\n`);

  for (const file of chapterFiles) {
    const chapterPath = path.join(copDir, file);
    const chapterData: ChapterJSON = JSON.parse(fs.readFileSync(chapterPath, 'utf-8'));

    console.log(`Chapter ${chapterData.chapterNumber}:`);

    const sections = extractSectionsFromChapter(chapterData.sections);
    let chapterLinks = 0;

    for (const section of sections) {
      const sectionId = `cop-${section.number}`;

      // Find detail code references in content
      const referencedCodes = findDetailReferences(section.content);

      for (const code of referencedCodes) {
        const detailId = detailCodeMap.get(code);

        if (detailId) {
          linksToCreate.push({
            sectionId,
            detailId,
            relationshipType: 'referenced',
            notes: `Detail ${code} referenced in section ${section.number} content`,
          });
          chapterLinks++;
        }
      }
    }

    console.log(`  Found ${chapterLinks} detail references\n`);
  }

  console.log(`Total links to create: ${linksToCreate.length}\n`);

  // Batch insert links
  if (linksToCreate.length > 0) {
    console.log('Inserting section-detail links...');
    const BATCH_SIZE = 50;

    for (let i = 0; i < linksToCreate.length; i += BATCH_SIZE) {
      const batch = linksToCreate.slice(i, i + BATCH_SIZE);
      await db.insert(copSectionDetails).values(batch);
      console.log(`  Inserted links ${i + 1}-${Math.min(i + BATCH_SIZE, linksToCreate.length)} of ${linksToCreate.length}`);
    }

    console.log('\n✓ Linking complete!');
  } else {
    console.log('No links found to create.');
    console.log('This is expected if detail codes are not explicitly referenced in COP text.');
    console.log('Manual curation may be needed to establish relationships.\n');
  }
}

linkCopSectionDetails()
  .then(() => {
    console.log('\nSection-detail linking completed successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Linking failed:', error);
    process.exit(1);
  });
```

**Key implementation details:**
- Reads per-chapter JSON files (faster than parsing 3.8MB monolith)
- Uses regex pattern matching to find detail code references (e.g., "F07", "P12")
- Only creates links for detail codes that exist in the `details` table
- Relationship type set to 'referenced' (explicit mention in COP text)
- May find 0 links if detail codes aren't explicitly referenced in text (normal - manual curation may be needed)

### Task 6: Add linking script to package.json
**File:** `C:\Users\LukeBoustridge\Projects\RANZ\Master Roofers Code of Practice\package.json`
**Action:** Modify
**Details:**

Add new script entry:

```json
"db:link-cop-section-details": "npx tsx lib/db/link-cop-section-details.ts"
```

Place after the `db:split-chapter-json` script.

### Task 7: Run section-detail linking
**File:** N/A (command execution)
**Action:** Execute
**Details:**

Run the linking script:

```bash
npm run db:link-cop-section-details
```

**Expected console output (if references found):**
```
Starting section-detail linking...

Loading existing details...
Loaded 251 existing details

Clearing existing section-detail links...
Existing links cleared

Processing 19 chapter files...

Chapter 1:
  Found 0 detail references

Chapter 2:
  Found 3 detail references

...

Chapter 8:
  Found 47 detail references

...

Total links to create: 127

Inserting section-detail links...
  Inserted links 1-50 of 127
  Inserted links 51-100 of 127
  Inserted links 101-127 of 127

✓ Linking complete!

Section-detail linking completed successfully!
```

**OR expected output (if no references found):**
```
Starting section-detail linking...

Loading existing details...
Loaded 251 existing details

Clearing existing section-detail links...
Existing links cleared

Processing 19 chapter files...

Chapter 1:
  Found 0 detail references
...

Total links to create: 0

No links found to create.
This is expected if detail codes are not explicitly referenced in COP text.
Manual curation may be needed to establish relationships.

Section-detail linking completed successfully!
```

**Note:** If zero links are found, this is acceptable. The COP text may not explicitly reference detail codes like "F07" — it may use narrative descriptions instead. Manual curation can be done in a future admin UI (Phase 16 or later). The table structure is ready for data when available.

## Verification

### File system verification
```bash
# Verify all 19 chapter files exist
ls public/cop/chapter-*.json | wc -l
# Expected: 19

# Check total size of all chapter files
du -sh public/cop/
# Expected: ~4-5 MB uncompressed

# Spot check Chapter 8 contains images
grep -c '"images"' public/cop/chapter-8.json
# Expected: > 0 (Chapter 8 has technical diagrams)

# Verify JSON is valid and minified (no pretty-printing)
head -c 200 public/cop/chapter-1.json
# Should show: {"chapterNumber":1,"title":"Introduction","version":"v25.12"...
# (single line, no whitespace between keys)
```

### Database verification
```sql
-- Verify per-chapter JSON matches database counts
SELECT chapter_number, COUNT(*) as sections
FROM cop_sections
GROUP BY chapter_number
ORDER BY chapter_number;
-- Compare to sectionCount field in each chapter-{N}.json file

-- Verify section-detail links created (if any found)
SELECT COUNT(*) FROM cop_section_details;
-- Expected: 0 to ~200 (depends on how many detail codes referenced in text)

-- If links exist, spot check them
SELECT
  cs.section_number,
  cs.title,
  d.code,
  d.name,
  csd.relationship_type
FROM cop_section_details csd
JOIN cop_sections cs ON csd.section_id = cs.id
JOIN details d ON csd.detail_id = d.id
LIMIT 10;
-- Should show section numbers, detail codes, and 'referenced' relationship type
```

### JSON structure verification
Load and inspect a chapter file:

```bash
# Pretty-print Chapter 1 to inspect structure
cat public/cop/chapter-1.json | python -m json.tool | head -50
```

Expected structure:
```json
{
  "chapterNumber": 1,
  "title": "Introduction",
  "version": "v25.12",
  "sectionCount": 12,
  "sections": [
    {
      "number": "1",
      "title": "Introduction",
      "level": 1,
      "content": "1 \nIntroduction \nThe NZ Metal Roof...",
      "pdfPages": [8, 9, 10, ...],
      "subsections": [
        {
          "number": "1.1",
          "title": "Disclaimer and Copyright",
          "level": 2,
          "content": "1.1 \nDisclaimer...",
          "pdfPages": [10],
          "subsections": [...]
        }
      ]
    }
  ]
}
```

### Compression estimation
Test Brotli compression on largest chapter:

```bash
# Compress Chapter 19 (largest)
cat public/cop/chapter-19.json | brotli -c | wc -c
# Expected: ~185-190 KB (70% compression from 619KB)

# If above 200KB compressed, consider warning user
```

**Note:** Chapter 19 may exceed 100KB compressed target. Document this as known issue. Consider pagination or splitting in future optimization if mobile performance testing shows impact.

## Notes

**Chapter JSON format:**
- Minified (no pretty-printing) for production
- Hierarchical structure matches database (subsections nested)
- Images embedded directly (no additional API calls needed)
- Version metadata from `metadata.json` (v25.12)
- Section count included for quick validation

**Section-detail linking:**
- Automated linking is best-effort (depends on explicit detail code references in text)
- If zero links found, this is acceptable — manual curation can happen later
- Relationship type 'referenced' means detail code explicitly mentioned in COP text
- Future relationship types: 'illustrates' (COP section explains detail), 'alternative' (COP offers alternative to detail)

**File sizes:**
- Total uncompressed: ~4-5 MB across 19 files
- Largest chapter: 19 (Revision History) at 619 KB uncompressed
- Brotli compression typically achieves ~70% reduction (619KB → ~186KB)
- Next.js automatically serves compressed versions (`.br`) to clients with Accept-Encoding: br

**Mobile performance:**
- Chapter 19 may exceed 100KB compressed target (research flag)
- All other chapters likely under 100KB compressed
- Test on throttled 4G: each chapter should load < 3s TTI
- If performance issues, consider:
  - Pagination for Chapter 19 (split into sub-pages)
  - Lazy-load sections below fold
  - Extract revision history to separate route

**Why JSON in /public/ not database:**
- Avoids PostgreSQL TOAST performance cliff (>2KB triggers TOAST, 2-10× slower queries)
- Enables CDN caching (static file, zero server load)
- Allows Brotli compression (Next.js automatic)
- Reduces database size (text content is ~4MB, now in static files)
- Faster delivery (single HTTP request vs recursive DB queries)

**Detail linking strategy:**
If automated linking finds few/no matches, consider:
1. Manual curation via admin UI (Phase 16+)
2. Keyword matching (e.g., "flashing" in COP text → link to flashing details)
3. Section number heuristics (e.g., Chapter 8 "Flashings" → link all flashing details)
4. Leave table empty, populate on-demand when users request linkage

**Re-running scripts:**
- `split-chapter-json.ts`: Idempotent, overwrites existing files (safe to re-run)
- `link-cop-section-details.ts`: Clears existing links before insert (safe to re-run)

**Next steps (subsequent phases):**
- Phase 14: Create `/cop/[sectionNumber]` route to render chapter JSON
- Phase 15: Add navigation chrome (sidebar, breadcrumbs)
- Phase 16: Supplementary panels (link to 3D models, HTG guides)
- Phase 17: HTG content extraction and `cop_section_htg` population
