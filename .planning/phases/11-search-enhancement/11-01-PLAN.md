---
phase: 11-search-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/migrations/0004_search_vector.sql
  - lib/db/migrations/meta/_journal.json
  - lib/db/schema.ts
  - lib/validations.ts
  - lib/search-helpers.ts
  - app/api/search/route.ts
autonomous: true

must_haves:
  truths:
    - "MRM content appears higher in results than equivalent RANZ content"
    - "Search query 'valley flashing' returns relevant results ordered by weighted relevance"
    - "API accepts consentMode parameter and filters to MRM only when true"
  artifacts:
    - path: "lib/db/migrations/0004_search_vector.sql"
      provides: "Generated tsvector column with GIN index"
      contains: "search_vector tsvector GENERATED ALWAYS"
    - path: "lib/search-helpers.ts"
      provides: "Search type detection (section, code, text)"
      exports: ["detectSearchType", "getSectionNavigationUrl"]
    - path: "app/api/search/route.ts"
      provides: "Source-weighted search with ts_rank"
      contains: "ts_rank"
  key_links:
    - from: "app/api/search/route.ts"
      to: "lib/db/schema.ts"
      via: "searchVector column"
      pattern: "details\\.searchVector"
    - from: "app/api/search/route.ts"
      to: "lib/search-helpers.ts"
      via: "detectSearchType import"
      pattern: "import.*detectSearchType"
---

<objective>
Add source-weighted full-text search with PostgreSQL ts_rank, GIN index, and consent mode API support.

Purpose: Enable search relevance ranking that prioritizes MRM authoritative content (2x boost) over RANZ supplementary content, fulfilling SEARCH-01 requirement. Provide API foundation for consent mode filtering (SEARCH-03) and section number navigation (SEARCH-04).

Output: Migration creating searchVector column, enhanced search API with ts_rank query path, search helper utilities for query type detection.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-search-enhancement/11-RESEARCH.md

@lib/db/schema.ts
@lib/validations.ts
@app/api/search/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration for search_vector column with GIN index</name>
  <files>
    lib/db/migrations/0004_search_vector.sql
    lib/db/migrations/meta/_journal.json
    lib/db/schema.ts
  </files>
  <action>
Create SQL migration file that adds a generated tsvector column to the details table:

1. In `lib/db/migrations/0004_search_vector.sql`:
```sql
-- Add generated search vector column for full-text search
-- Weights: name=A (highest), description=B, specifications=C (lowest)
ALTER TABLE details
ADD COLUMN search_vector tsvector
GENERATED ALWAYS AS (
  setweight(to_tsvector('english', name), 'A') ||
  setweight(to_tsvector('english', COALESCE(description, '')), 'B') ||
  setweight(to_tsvector('english', COALESCE(specifications::text, '')), 'C')
) STORED;

-- Create GIN index for fast full-text search
CREATE INDEX idx_details_search_vector ON details USING gin(search_vector);

-- Add comment for documentation
COMMENT ON COLUMN details.search_vector IS 'Generated full-text search vector: name (A), description (B), specifications (C)';
```

2. Update `lib/db/migrations/meta/_journal.json` to add entry:
```json
{
  "idx": 3,
  "version": "7",
  "when": 1738540000000,
  "tag": "0004_search_vector",
  "breakpoints": true
}
```

3. In `lib/db/schema.ts`, add searchVector column to details table definition:
- Add import for `customType` from drizzle-orm/pg-core if not present
- Define searchVector as custom type (read-only, database generates it):
```typescript
// After existing columns in details table
searchVector: text('search_vector'), // Generated column - read-only (DB generates via migration)
```
Note: We declare it as text to satisfy TypeScript; the actual tsvector type is created by migration. Drizzle doesn't natively support tsvector but we can query it with raw SQL.

4. Run migration against database:
```bash
npx drizzle-kit push
```
  </action>
  <verify>
Run `npx drizzle-kit push` successfully. Then verify with:
```bash
psql $DATABASE_URL -c "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='details' AND column_name='search_vector';"
```
Should return: search_vector | tsvector
  </verify>
  <done>
searchVector column exists in details table as tsvector type with GIN index. Column is auto-populated from name, description, specifications fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create search helper utilities</name>
  <files>
    lib/search-helpers.ts
  </files>
  <action>
Create new file `lib/search-helpers.ts` with query type detection and section navigation utilities:

```typescript
/**
 * Search helper utilities for query type detection and section navigation.
 * Used by search API to route queries appropriately.
 */

// Section number format: "4.3" or "4.3.2" (COP chapter.section or chapter.section.subsection)
const SECTION_NUMBER_REGEX = /^\d+\.\d+(\.\d+)?$/;

// Detail code format: Letter followed by 1-3 digits (e.g., "F07", "R12", "V3")
const DETAIL_CODE_REGEX = /^[A-Z]\d{1,3}$/i;

export type SearchType = 'section' | 'code' | 'text';

/**
 * Detects the type of search query to determine routing.
 * - 'section': COP section number (e.g., "4.3.2") -> navigates to COP structure
 * - 'code': Detail code (e.g., "F07") -> exact code lookup
 * - 'text': General text search -> full-text search with ts_rank
 */
export function detectSearchType(query: string): SearchType {
  const trimmed = query.trim();

  // Check for section number first (e.g., "4.3.2")
  if (SECTION_NUMBER_REGEX.test(trimmed)) {
    return 'section';
  }

  // Check for exact detail code (e.g., "F07")
  if (DETAIL_CODE_REGEX.test(trimmed)) {
    return 'code';
  }

  return 'text';
}

/**
 * Generates navigation URL for COP section number.
 * Maps section numbers to detail filter URLs.
 *
 * Example: "4.3.2" -> "/search?section=4.3.2&source=mrm-cop"
 *
 * Note: Full section hierarchy navigation requires copSectionNumber field
 * to be populated in details table (future content import task).
 * For now, passes section number as search query with MRM filter.
 */
export function getSectionNavigationUrl(sectionNumber: string): string {
  const normalized = sectionNumber.trim();
  // Until section numbers are seeded in database, search by section number text
  // with MRM source filter (section numbers only exist in MRM COP)
  return `/search?q=${encodeURIComponent(normalized)}&source=mrm-cop`;
}

/**
 * Source authority multipliers for search relevance scoring.
 * MRM COP is authoritative (2x boost), RANZ Guide is supplementary (1x).
 */
export const SOURCE_RELEVANCE_MULTIPLIERS: Record<string, number> = {
  'mrm-cop': 2.0,
  'ranz-guide': 1.0,
  'membrane-cop': 1.0, // Future source
};

/**
 * Gets relevance multiplier for a source ID.
 * Unknown sources default to 1.0 (no boost).
 */
export function getSourceRelevanceMultiplier(sourceId: string | null): number {
  if (!sourceId) return 1.0;
  return SOURCE_RELEVANCE_MULTIPLIERS[sourceId] ?? 1.0;
}
```
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit lib/search-helpers.ts
```
Should compile without errors.
  </verify>
  <done>
lib/search-helpers.ts exports detectSearchType, getSectionNavigationUrl, SOURCE_RELEVANCE_MULTIPLIERS, getSourceRelevanceMultiplier functions for search routing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance search API with ts_rank and source weighting</name>
  <files>
    app/api/search/route.ts
    lib/validations.ts
  </files>
  <action>
Enhance the search API to use PostgreSQL full-text search with source-weighted relevance:

1. In `lib/validations.ts`, update searchQuerySchema to add source and consentMode parameters:
```typescript
export const searchQuerySchema = z.object({
  q: z.string().min(1, 'Search query is required'),
  substrate: z.string().optional(),
  category: z.string().optional(),
  source: z.string().optional(), // NEW: Filter by source (mrm-cop, ranz-guide)
  consentMode: z.enum(['true', 'false']).optional().transform(v => v === 'true'), // NEW: Consent mode
  hasWarnings: z.enum(['true', 'false']).optional().transform(v => v === 'true'),
  hasFailures: z.enum(['true', 'false']).optional().transform(v => v === 'true'),
  type: z.enum(['details', 'failures', 'all', 'code']).default('all'),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  offset: z.coerce.number().int().min(0).default(0),
});
```

2. Rewrite `app/api/search/route.ts` to use ts_rank with source weighting:

Key changes:
- Import detectSearchType, getSectionNavigationUrl from lib/search-helpers
- Add section number detection at start of handler
- Replace ILIKE queries with ts_rank queries for text search type
- Apply source relevance multiplier (MRM 2x) in ORDER BY
- Add consentMode filter (sourceId = 'mrm-cop' when true)
- Keep ILIKE only for exact code lookups
- Use websearch_to_tsquery to handle natural language input safely
- Return sourceId in results for client-side grouping

The enhanced API should:
a) Detect section numbers and return redirect URL
b) Handle exact code matches with ILIKE (fast path)
c) Use ts_rank for text queries with weighted scoring
d) Apply 2x multiplier to MRM results before ORDER BY
e) Filter to MRM only when consentMode=true
f) Include sourceId in all result objects

SQL query pattern for full-text search:
```sql
SELECT
  d.id, d.code, d.name, d.description, d.source_id, d.thumbnail_url,
  d.substrate_id, d.category_id,
  ts_rank(d.search_vector, websearch_to_tsquery('english', $1)) *
    CASE WHEN d.source_id = 'mrm-cop' THEN 2.0 ELSE 1.0 END as relevance_score
FROM details d
WHERE d.search_vector @@ websearch_to_tsquery('english', $1)
  AND ($2 IS NULL OR d.source_id = $2)
ORDER BY relevance_score DESC, d.code ASC
LIMIT $3 OFFSET $4
```

Use Drizzle's sql template literal for raw queries where ts_rank is needed.
  </action>
  <verify>
Test search API with curl:
```bash
# Text search (should use ts_rank)
curl "http://localhost:3000/api/search?q=valley+flashing" | jq '.results[0:3] | .[].sourceId'

# Should return results with sourceId field, MRM results appearing higher

# Consent mode (MRM only)
curl "http://localhost:3000/api/search?q=valley&consentMode=true" | jq '.results[].sourceId'
# Should return only 'mrm-cop' sources

# Section number detection
curl "http://localhost:3000/api/search?q=4.3.2" | jq '.redirect'
# Should return redirect URL to section
```
  </verify>
  <done>
Search API uses ts_rank for text queries with MRM 2x relevance boost. Consent mode filters to MRM only. Section numbers return redirect URLs. All results include sourceId for client grouping.
  </done>
</task>

</tasks>

<verification>
1. Migration applied: `search_vector` column exists in details table with GIN index
2. Search helpers: `detectSearchType('4.3.2')` returns 'section', `detectSearchType('F07')` returns 'code', `detectSearchType('valley flashing')` returns 'text'
3. API ts_rank: Search for "valley" returns results ordered by relevance with MRM results boosted
4. Consent mode: `?consentMode=true` returns only sourceId='mrm-cop' results
5. Source in response: All result objects include `sourceId` field
</verification>

<success_criteria>
- Database has searchVector column (tsvector) with GIN index
- Search API uses ts_rank for text queries with 2x MRM multiplier
- API accepts consentMode parameter and filters correctly
- API detects section numbers and returns redirect
- All results include sourceId for client-side grouping
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-search-enhancement/11-01-SUMMARY.md`
</output>
