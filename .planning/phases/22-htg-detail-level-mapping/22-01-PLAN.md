---
phase: 22-htg-detail-level-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/db/map-htg-to-details.ts
  - lib/db/queries/htg-detail.ts
  - package.json
autonomous: true
must_haves:
  truths:
    - "HTG pages are mapped to specific detail codes in the database (not just chapter root sections)"
    - "Query function returns HTG content for a given detail ID"
    - "Mapping script can be re-run idempotently (delete-then-insert pattern)"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "detailHtg junction table definition"
      contains: "detailHtg"
    - path: "lib/db/map-htg-to-details.ts"
      provides: "CLI script that maps HTG pages to detail codes via keyword matching"
      exports: []
    - path: "lib/db/queries/htg-detail.ts"
      provides: "getHtgForDetail query function"
      exports: ["getHtgForDetail"]
  key_links:
    - from: "lib/db/map-htg-to-details.ts"
      to: "lib/db/schema.ts"
      via: "detailHtg table insert"
      pattern: "db\\.insert\\(detailHtg\\)"
    - from: "lib/db/queries/htg-detail.ts"
      to: "lib/db/schema.ts"
      via: "detailHtg + htgContent join query"
      pattern: "detailHtg.*htgContent"
---

<objective>
Create the detail-level HTG mapping infrastructure: a new junction table linking HTG content records to specific detail codes, a keyword-based mapping script to populate it, and a query function to retrieve HTG content for a detail page.

Purpose: Phase 17 mapped HTG pages to COP chapter root sections only. This plan creates the finer-grained mapping to individual detail codes (F07, P18, etc.) so HTG content can appear on detail pages.

Output: detailHtg table in schema, populated mapping script, getHtgForDetail query function.
</objective>

<execution_context>
@C:/Users/LukeBoustridge/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/LukeBoustridge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/db/schema.ts
@lib/db/map-htg-to-cop.ts
@lib/db/queries/supplementary.ts
@lib/db/import-htg-content.ts
@mrm_extract/details.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create detailHtg junction table and mapping script</name>
  <files>
    lib/db/schema.ts
    lib/db/map-htg-to-details.ts
    package.json
  </files>
  <action>
1. **Add detailHtg table to schema.ts** (after the copSectionHtg definition):

```ts
export const detailHtg = pgTable('detail_htg', {
  detailId: text('detail_id').references(() => details.id, { onDelete: 'cascade' }).notNull(),
  htgId: text('htg_id').references(() => htgContent.id, { onDelete: 'cascade' }).notNull(),
  relevance: text('relevance'),  // 'primary' | 'supplementary'
  matchType: text('match_type'), // 'keyword' | 'category' | 'manual'
  notes: text('notes'),
}, (table) => ({
  pk: primaryKey({ columns: [table.detailId, table.htgId] }),
  detailIdx: index('idx_detail_htg_detail').on(table.detailId),
  htgIdx: index('idx_detail_htg_htg').on(table.htgId),
}));
```

2. **Create `lib/db/map-htg-to-details.ts`** — a CLI script that maps HTG content to detail codes using keyword/category matching. Follow the two-mode pattern from `map-htg-to-cop.ts` (--suggest for analysis, --insert for database population).

Matching strategy (multi-signal approach):

**Category-level mapping (broadest):**
- HTG sourceDocument='flashings' → all details with category='flashings' (F01-F53)
- HTG sourceDocument='penetrations' → all details with category='penetrations' (P01-P49)
- HTG sourceDocument='cladding' → details with category='junctions' (J01-J09, since junctions involve cladding connections)

**Keyword matching (finer grain):**
For each HTG page's content text, check for matches against detail names and descriptions. Normalize both to lowercase. Use these keyword groups derived from detail names:
- 'ridge' → matches F01 "Ridge and Hip Intersections", F02 "Ridge-hip Intersection", F03 "Ridge End", J03 "Ridge-Hip Junction"
- 'valley' → matches D-codes in drainage with "valley", J01/J02 "Valley Junction"
- 'barge' → matches F04 "Barge And Verge", F06-F09 "Stepped Fascia...Barge"
- 'apron' → matches relevant flashing details
- 'penetration' / 'pipe' / 'vent' / 'chimney' / 'skylight' → P-codes
- 'gutter' → D-codes with "gutter"
- 'curb' → P09 "Curb Design", P10 "Level Back Curbs"
- 'soaker' → flashing details with "soaker"
- 'fascia' → F06-F09
- 'dormer' → J06 "Gable Dormer Valley-Apron Junction"
- 'wall' / 'cladding' → J07/J08 wall-to-roof junction details

For each HTG page, scan its content for the detail's name (lowercased). If the detail name appears in the HTG content, create a mapping with matchType='keyword'.

If no keyword match but the detail's category matches the HTG sourceDocument category, create a mapping with matchType='category' and relevance='supplementary'.

**Relevance assignment:**
- 'keyword' match → relevance='primary' (HTG page specifically discusses this detail type)
- 'category' match → relevance='supplementary' (general guide for the category)

**--suggest mode:** Print all suggested mappings grouped by sourceDocument with match counts. No DB changes.

**--insert mode:** Delete existing detail_htg records, then insert all mappings. Print summary with counts per sourceDocument and match type.

3. **Add npm script** to package.json:
```json
"db:map-htg-to-details": "npx tsx lib/db/map-htg-to-details.ts"
```

**Important implementation notes:**
- Load environment variables with `import { config } from 'dotenv'; config({ path: '.env.local' });` at top of file.
- Query htgContent table for all records to get their content and sourceDocument.
- Query details table for all records to get their id, code, name, description, and categoryId.
- Use batch insert (50 records per batch) for efficiency.
- Follow the idempotent delete-then-insert pattern from map-htg-to-cop.ts.
- Do NOT query the database for category-to-sourceDocument mapping — use a hardcoded mapping object: `{ flashings: 'flashings', penetrations: 'penetrations', junctions: 'cladding' }`.
  </action>
  <verify>
Run `npx tsx lib/db/map-htg-to-details.ts -- --suggest` to verify the script loads, queries both tables, and outputs suggested mappings without error. Verify the output shows mappings grouped by sourceDocument with both keyword and category match types. The script should NOT modify the database in suggest mode.
  </verify>
  <done>
detailHtg table defined in schema.ts. map-htg-to-details.ts script created with --suggest and --insert modes. npm script added. --suggest mode outputs mapping suggestions showing HTG pages matched to specific detail codes by keyword and category signals. Batch insert ready in --insert mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create getHtgForDetail query and run mapping insert</name>
  <files>
    lib/db/queries/htg-detail.ts
  </files>
  <action>
1. **Create `lib/db/queries/htg-detail.ts`** with:

```ts
import { db } from '@/lib/db';
import { detailHtg, htgContent } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';

export interface HtgDetailContent {
  htgId: string;
  guideName: string;
  sourceDocument: string;
  content: string | null;
  pdfPage: number | null;
  relevance: string | null;
  matchType: string | null;
}

/**
 * Get all HTG content mapped to a specific detail.
 * Returns HTG pages linked via detail_htg junction table,
 * ordered with 'primary' relevance first, then 'supplementary'.
 */
export async function getHtgForDetail(detailId: string): Promise<HtgDetailContent[]> {
  const results = await db
    .select({
      htgId: htgContent.id,
      guideName: htgContent.guideName,
      sourceDocument: htgContent.sourceDocument,
      content: htgContent.content,
      pdfPage: htgContent.pdfPage,
      relevance: detailHtg.relevance,
      matchType: detailHtg.matchType,
    })
    .from(detailHtg)
    .innerJoin(htgContent, eq(detailHtg.htgId, htgContent.id))
    .where(eq(detailHtg.detailId, detailId));

  // Sort: primary first, then supplementary
  return results.sort((a, b) => {
    if (a.relevance === 'primary' && b.relevance !== 'primary') return -1;
    if (a.relevance !== 'primary' && b.relevance === 'primary') return 1;
    return (a.pdfPage ?? 0) - (b.pdfPage ?? 0);
  });
}
```

2. **Run the insert mode** of the mapping script to populate the database:
```bash
npx tsx lib/db/map-htg-to-details.ts -- --insert
```

Verify the script completes with a summary showing total mappings inserted, broken down by sourceDocument and match type.

**Important:** If the insert fails because the detail_htg table doesn't exist in the database yet, run `npx drizzle-kit push` first to push the schema changes, then retry the insert. Use `drizzle-kit push` (not `drizzle-kit migrate`) since this project uses push mode.
  </action>
  <verify>
Verify by checking: (1) `lib/db/queries/htg-detail.ts` exports `getHtgForDetail`. (2) The database has been populated — run a quick validation: `npx tsx -e "import { config } from 'dotenv'; config({ path: '.env.local' }); import { db } from './lib/db/index'; import { detailHtg } from './lib/db/schema'; const rows = await db.select().from(detailHtg).limit(5); console.log('Sample rows:', rows.length); process.exit(0);"` (should return rows > 0). TypeScript compilation check: `npx tsc --noEmit lib/db/queries/htg-detail.ts` or check that the import resolves correctly.
  </verify>
  <done>
getHtgForDetail query function created and exported. detail_htg table pushed to database. Mapping script run with --insert mode, populating HTG-to-detail mappings. Database contains HTG page references linked to specific detail codes.
  </done>
</task>

</tasks>

<verification>
1. `lib/db/schema.ts` contains `detailHtg` table definition with `detailId`, `htgId`, `relevance`, `matchType`, `notes` columns and composite primary key
2. `lib/db/map-htg-to-details.ts` exists with `--suggest` and `--insert` modes
3. `lib/db/queries/htg-detail.ts` exports `getHtgForDetail(detailId)` returning array of `HtgDetailContent`
4. `package.json` has `db:map-htg-to-details` script
5. Database `detail_htg` table is populated with mappings (verify at least 50 rows exist)
</verification>

<success_criteria>
- HTG pages are mapped to specific detail codes in the database
- getHtgForDetail('F07') returns relevant flashings HTG content
- getHtgForDetail('P10') returns relevant penetrations HTG content
- Mapping script is idempotent (can be re-run safely)
</success_criteria>

<output>
After completion, create `.planning/phases/22-htg-detail-level-mapping/22-01-SUMMARY.md`
</output>
